<?php
// $Id: agenda.module,v 1.1 2009/05/14 14:02:09 aidan Exp $

/**
 * Display help and module information
 * @param path which path of the site we're displaying help
 * @param arg array that holds the current path as would be returned from arg() function
 * @return help text for the path
 */
function agenda_help($path, $arg) {
  $output = '';  //declare your output variable
  switch ($path) {
    case "admin/help#agenda":
      $output = '<p>'.  t("Displays an agenda of events for a facebook entity") .'</p>';
      break;
  }
  return $output;
}


/**
 * Valid permissions for this module
 * @return array An array of valid permissions for the onthisdate module
 */
function agenda_perm() {
  return array('access agenda content');
}


/**
 * Implementation of hook_block
 */
function agenda_block($op='list', $delta=0) {
  switch($op) {
    case 'list':
      $blocks[0] = array(
        'info'  => t("Agenda"),
        'cache' => BLOCK_CACHE_GLOBAL,
        );
      return $blocks;
      break;
      
    case 'view':
      $basepath = drupal_get_path('module', 'agenda');
      drupal_add_css($basepath . '/css/agenda-block.css');
      drupal_add_js($basepath . '/js/agenda.js');
      drupal_add_js($basepath . '/js/jquery.corners.js');
      $block = array(
        'subject' => t('Upcoming'),
        'content' => agenda_display_block(),
      );
      return $block;
      break;
  }
}


/**
 *
 */
function agenda_display_block() {    
    // Define all of our calendar sources
    $calendars = variable_get('agenda_calendars', '');
    $calendars = preg_split('@\r\n?|\n@', $calendars);
    if (empty($calendars)) {
        return;
    }

    // Fetch the calendar data
    $events = _fetch_events($calendars);

    // Group the events by date
    $groupedevents = array();
    foreach ($events as $event) {
        $groupedevents[$event['when']][] = $event;
    }
    ksort($groupedevents);
        
    // Filter the events based on their date
    $old = strtotime(variable_get('agenda_old', 'yesterday'));
    $datelimit = variable_get('agenda_datelimit', 4);
    $count = 0;
    $events = array();
    foreach ($groupedevents as $date => $eventdata) {        
        if ($date <= $old) { continue; }
        if ($count >= $datelimit) { break; }
        $events[$date] = $eventdata;
        $count++;
    }
    
    // Render
    if (count($events)) {
        return theme('agenda_block', $events);
    }
}


/**
 * Given a list of calendar IDs, parse out and return any event data
 *
 * @param array $calendars the calendar ids
 */
function _fetch_events($calendars) {
    // Check the cache
    $eventdata = cache_get('agenda_eventdata', 'cache');
    if (is_object($eventdata)) {
        $eventdata = $eventdata->data;
    }

    // Otherwise parse the calendars and cache the eventdata
    if (!$eventdata) {
        $sourcepattern = 'http://www.google.com/calendar/feeds/%s/public/basic';
        $eventdata = array();
        foreach ($calendars as $calindex => $googleid) {
            $source = sprintf($sourcepattern, urlencode(check_plain($googleid)));
            $calendar = @simplexml_load_file($source);
            
            // If we fail to load the XML, handle it
            if (!$calendar) {
                continue;
            }
            
            // Parse out the event details
            foreach ($calendar->entry as $event) {
                $thisevent = array();
                $content = explode('<br />', $event->content);
                foreach ($content as $item) {
                    $item = trim($item);
                    if (empty($item) || !strpos($item, ':')) { continue; }
                    list ($key, $value) = explode(':', $item, 2);
                    $thisevent[strtolower(trim(check_plain($key)))] = filter_xss(trim($value));
                }
                
                // Make sure we have a when
                // This means no support for recurring events
                if (!isset($thisevent['when'])) {
                    continue;
                }
                
                // Special processing for some fields
                $thisevent['index']    = (int) $calindex;
                $thisevent['calendar'] = (string) $calendar->title;
                $thisevent['when']     = strtotime($thisevent['when']);
                $thisevent['title']    = (string) $event->title;
                $eventdata[] = $thisevent;
            }
        }
        
        // Cache our data
        $expires = time() + variable_get('agenda_cachetime', 3600);
        cache_set('agenda_eventdata', $eventdata, 'cache', $expires);
    }
    
    return $eventdata;
}


/**
 * Implementation of hook_theme
 */
function agenda_theme($existing, $type, $theme, $path) {
    $theme = array(
        'agenda_block' => array(
          'arguments' => array('events' => array()),
          'template' => 'theme/agenda-block',
        ),
    );
    
    return $theme;
}


/**
 * Implementation of hook_menu
 */
function agenda_menu() {

  $items = array();

  $items['admin/settings/agenda'] = array(
    'title' => 'Agenda',
    'description' => 'Configure rendering options and specify calendar sources',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('agenda_admin'),
    'access arguments' => array('access administration pages'),
    'type' => MENU_NORMAL_ITEM,
   );

  return $items;
}


/**
 * Admin configuration page
 */
function agenda_admin() {

  $form['agenda_old'] = array(
    '#type' => 'textfield',
    '#title' => t('Define old'),
    '#default_value' => variable_get('agenda_old', 'yesterday'),
    '#description' => t("A string indicating what old really is - events before this are not shown."),
    '#required' => TRUE,
  );
  
  $form['agenda_datelimit'] = array(
    '#type' => 'textfield',
    '#title' => t('Dates to display'),
    '#default_value' => variable_get('agenda_datelimit', 4),
    '#description' => t("The maximum number of unique dates to display."),
    '#required' => TRUE,
  );
  
  $form['agenda_cachetime'] = array(
    '#type' => 'textfield',
    '#title' => t('Amount of time to cache ICS data'),
    '#default_value' => variable_get('agenda_cachetime', 3600),
    '#description' => t("How long (in seconds) the module should hold onto the ICS data before re-requesting it from Google."),
    '#required' => TRUE,
  );
  
  $form['agenda_calendars'] = array(
    '#type' => 'textarea',
    '#title' => t('Google Calendar IDs'),
    '#default_value' => variable_get('agenda_calendars', ''),
    '#rows' => 4,
    '#description' => t("The public IDs of each google calendar you want to display, each on a newline."),
    '#required' => TRUE,
  );

  return system_settings_form($form);
}


/**
 * Implementation of hook_admin_validates
 */
function agenda_admin_validate($form, &$form_state) {
  // calendars (has the form of a valid email address)
  $calendars = $form_state['values']['agenda_calendars'];
  $ids = preg_split('@\r\n?|\n@', $calendars);
  if (empty($ids)) {
    form_set_error('agenda_calendars', t('Field can not be left blank'));
  }
  foreach ($ids as $id) {
    if (!valid_email_address($id)) {
      form_set_error('agenda_calendars', t('Invalid calendar ID'));
    }
  }
  
  // old (strtotime parseable)
  $old = $form_state['values']['agenda_old'];
  if (false === strtotime($old)) {
    form_set_error('onthisdate_old', t('Unable to parse input with strtotime'));
  }
  
  // datelimit (positive integer)
  $datelimit = $form_state['values']['agenda_datelimit'];
  if (!is_numeric($datelimit)) {
    form_set_error('agenda_datelimit', t('You must specify a number.'));
  }
  else if ($datelimit <= 0) {
    form_set_error('agenda_datelimit', t('The number must be positive.'));
  }
  
  // cachetime (positive integer)
  $cachetime = $form_state['values']['agenda_cachetime'];
  if (!is_numeric($cachetime)) {
    form_set_error('agenda_cachetime', t('You must specify the number of seconds to cache calendar data.'));
  }
  else if ($cachetime <= 0) {
    form_set_error('agenda_cachetime', t('The cache time must be positive.'));
  }
}
